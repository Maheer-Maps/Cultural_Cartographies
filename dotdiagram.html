<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>London Cultural Venues (2018 vs 2023)</title>
  <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Cormorant:ital,wght@0,300..700;1,300..700&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Manrope:wght@200..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Rubik+Mono+One&family=Special+Gothic+Expanded+One&family=Tilt+Warp&family=Urbanist:wght@100..900&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
      background-color: #333432;
    }
    .switch {
      position: absolute;
      top: 10px;
      left: 10px;
      border: 1px solid white;
      padding: 6px 15px;
      border-radius: 20px;
      background-color: transparent;
      font-size: 0.85rem;
      cursor: pointer;
      z-index: 10;
      font-family: "Bricolage Grotesque", sans-serif;
      color:white;
      text-transform: uppercase;
    }
    .tooltip {
      position: absolute;
      background: white;
      padding: 6px 10px;
      border: 1px solid #ccc;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>
  <div class="switch" onclick="toggleYear()">Switch to 2023</div>
  <svg></svg>
  <div class="tooltip" id="tooltip"></div>

  <script>
    let discontinuedCategories = [
      "Live in Artists' Workspace",
      "Outdoor Spaces for Cultural Use",
      "Music (Office Based Businesses)",
      "Legal Street Art Walls",
      "Community Centres",
      "Large Scale Screen Based Media Production Studios",
      "Pubs",
      "Skate Parks"
    ];

    const svg = d3.select("svg");
    const width = window.innerWidth;
    const height = window.innerHeight;

    const gradient = d3.interpolateRgbBasis(["#CC95F3", "#A2F2D5","#2F4CFF", "#1DED3C"]);
    let colorScale;

    function buildColorScale(categories) {
      const n = categories.length;
      const tValues = Array.from({ length: n }, (_, i) => i / (n - 1));
      for (let i = tValues.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tValues[i], tValues[j]] = [tValues[j], tValues[i]];
      }
      const categoryMap = new Map();
      categories.sort();
      categories.forEach((cat, i) => {
        categoryMap.set(cat, gradient(tValues[i]));
      });
      colorScale = d => categoryMap.get(d);
    }

    let year = "2018";
    let allData = { "2018": [], "2023": [] };
    let maxGroupedNodeCount = 0;
    let cachedLayout = null;

    async function loadCSVData() {
      const url = "combined_cultural_data_clean.csv";
      try {
        const data = await d3.csv(url);
        allData["2018"] = data.filter(d => d.year === "2018");
        allData["2023"] = data.filter(d => d.year === "2023");

        const allCategories = Array.from(new Set(data.map(d => d.category)));
        buildColorScale(allCategories);

        const categories2018 = new Set(allData["2018"].map(d => d.category));
        const categories2023 = new Set(allData["2023"].map(d => d.category));
        discontinuedCategories = [...categories2018].filter(cat => !categories2023.has(cat));

        render();
      } catch (e) {
        console.error("Failed to load CSV:", e);
      }
    }

    const discontinuedColor = "#D3D3D3";

    function getColor(d) {
      if (year === "2023" && discontinuedCategories.includes(d.category)) {
        return discontinuedColor;
      }
      return colorScale(d.category);
    }

    function computeOpacity(d) {
      const isDiscontinued = discontinuedCategories.includes(d.category);
      if (year === "2018") {
        return d.exists2018 ? 1 : 0;
      } else {
        if (!d.exists2023) {
          return isDiscontinued ? 0.1 : 0;
        }
        return isDiscontinued ? 0.1 : 1;
      }
    }

    function render() {
      const venuesById = {};
      allData["2018"].forEach((d, i) => {
        const id = d.name || `${d.category}-${i}`;
        venuesById[id] = { ...d, id, exists2018: true };
      });
      allData["2023"].forEach((d, i) => {
        const id = d.name || `${d.category}-${i}`;
        if (venuesById[id]) {
          venuesById[id].exists2023 = true;
        } else {
          venuesById[id] = { ...d, id, exists2023: true };
        }
      });

      const visibleNodes = Object.values(venuesById)
        .filter(d => {
          if (year === "2018") return d.exists2018;
          return d.exists2023 || discontinuedCategories.includes(d.category);
        })
        .sort((a, b) => d3.ascending(a.category, b.category));

        

        const groupedNodes = [];
let groupIndex = 0;
const categoryGroups = d3.group(visibleNodes, d => d.category);

for (const [category, items] of categoryGroups) {
  for (let i = 0; i < items.length; i += 2) {
    const groupItems = [items[i], items[i + 1]].filter(Boolean);
    groupedNodes.push({
      id: `group-${groupIndex++}`,
      items: groupItems,
      category: category
    });
  }
}


maxGroupedNodeCount = groupedNodes.length;

const marginRatio = 0.1;
const usableWidth = width * (1 - marginRatio * 2);
const usableHeight = height * (1 - marginRatio * 2);

let columns = Math.ceil(Math.sqrt(maxGroupedNodeCount * (usableWidth / usableHeight)));
let rows = Math.ceil(maxGroupedNodeCount / columns);
let stepX = usableWidth / columns;
let stepY = usableHeight / rows;
let circleRadius = Math.min(stepX, stepY) * 0.4;

while (rows * stepY > usableHeight && columns > 1) {
  columns--;
  rows = Math.ceil(maxGroupedNodeCount / columns);
  stepX = usableWidth / columns;
  stepY = usableHeight / rows;
  circleRadius = Math.min(stepX, stepY) * 0.4;
}

const offsetX = (width - columns * stepX) / 2;
const offsetY = (height - rows * stepY) / 2;
cachedLayout = { columns, rows, stepX, stepY, circleRadius, offsetX, offsetY };


      groupedNodes.forEach((d, i) => {
        const col = i % cachedLayout.columns;
        const row = Math.floor(i / cachedLayout.columns);
        d.gridX = cachedLayout.offsetX + col * cachedLayout.stepX;
        d.gridY = cachedLayout.offsetY + row * cachedLayout.stepY;
      });

      const circles = svg.selectAll("circle").data(groupedNodes, d => d.id);

      circles.enter().append("circle")
        .attr("r", cachedLayout.circleRadius)
        .attr("cx", d => d.gridX)
        .attr("cy", d => d.gridY)
        .attr("fill", d => getColor({ category: d.category }))
        .attr("opacity", d => computeOpacity({ category: d.category, exists2018: true, exists2023: true }))
        .merge(circles)
        .transition()
        .duration(800)
        .attr("fill", d => getColor(d.items[0]))
        .attr("opacity", d => computeOpacity(d.items[0]));

      circles.exit()
        .transition()
        .duration(800)
        .style("opacity", 0)
        .remove();

      const tooltip = d3.select("#tooltip");

      svg.selectAll("circle")
        .on("mouseover", (event, d) => {
          tooltip.style("opacity", 1)
          .html(`<strong>${[...new Set(d.items.map(i => i.category))].join(", ")}</strong>`);

        })
        .on("mousemove", (event) => {
          tooltip.style("left", (event.pageX + 10) + "px")
                 .style("top", (event.pageY - 20) + "px");
        })
        .on("mouseout", () => {
          tooltip.style("opacity", 0);
        });
    }

    function toggleYear() {
      year = year === "2018" ? "2023" : "2018";
      document.querySelector(".switch").innerText = `Switch to ${year === "2018" ? "2023" : "2018"}`;
      render();
    }

    loadCSVData();
  </script>
</body>
</html>